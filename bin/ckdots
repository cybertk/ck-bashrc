#!/usr/bin/env bash

# dot vs dotfile
#  - dot is .vimrc
#  - dotfile is path of .vimrc, i.e. ~/.vimrc

_DEFAULT_FILES=""
_SHELL_PROFILES=".bashrc .bash_profile"
_DOTS_IGNORED=(.DS_Store)

install_backup() {
    declare dots="$1" backup_dir="$2"
    local dest

    # Ensure destination dir exist
    dest="$backup_dir/$(date "+%Y%m%d-%H%M%S")"
    mkdir -p "$dest"

    for dot in $dots $_SHELL_PROFILES; do
        local f

        f="$HOME/$dot"

        # Skiping if file un-exist
        [[ -e "$f" ]] || continue

        # TODO: detect if file is same as in dots-config
        echo "==> Backing up $dot"
        cp -r "$f" "$dest"
    done
    echo "==> All dots are backed up to $dest"
}

install_profile() {
    declare profile="$1" config_path="$2"

    echo "==> Installing profile $profile"
    cat >"$HOME/$profile" <<EOF
#!/bin/sh

# NOTE: Do **NOT** edit this file.
#   This file is automated generated by ckdots cybertk/ckdots.
#   Edit profile/bashrc instead.

CKDOTS_ROOT="$PWD"
CKDOTS_CONFIG="${config_path}"
. \${CKDOTS_ROOT}/profile
EOF
}

# Install one dotfile($1) to $HOME
install_dot_file() {
    local dot_file="$1" dest_dir="$2"

    echo "==> Installing dotfile $dot"
    ln -sf "$dot_file" "$dest_dir/$(basename "$dot_file")"
}

install_main() {
    declare dots="$1" path="$2"

    for dot in $dots; do
        local f="$path/dots/$dot"

        install_dot_file "$f"
    done
    install_profile .bash_profile "$path"
    install_profile .bashrc "$path"
}

# Usage:
# install - Install/Restore configs on a new machine
# save - Save new dot file
install() {
    local config_path dots

    config_path=${CKDOTS_CONFIG:-~/.ckdots}

    # 0, Load dots from config repo
    # 1, Load from repo: ckdots-config
    # 2, Load from env: $CKDOTS_FILES
    # 3, Fallback to defaults
    if [[ -f "$CKDOTS_CONFIG/config.sh" ]]; then
        # shellcheck source=/dev/null
        . "$CKDOTS_CONFIG/config.sh"
        dots=$CONFIG_DOTS
        echo "==> Load dots from config:$CKDOTS_CONFIG: $dots"
    elif [[ -n "$CKDOTS_FILES" ]]; then
        dots=$CKDOTS_FILES
        echo "==> Reading files from \$CKDOTS_FILES: $CKDOTS_FILES"
    fi

    if [[ -z "$dots" ]]; then
        ${dots:=$_DEFAULT_FILES}
        echo "==> Falling back to default files: $dots"
    fi

    install_backup "$dots" "$config_path/backup"
    install_main "$dots" "$config_path"
}

usage() {
    echo "
Available commands:

   install           Install on a new device
   ls                List all saved dotfiles
   add               Add new dotfile
   checkout          Checkout saved dotfiles to HOME
   help              Print this help
"
}

# For \; vs +, see https://unix.stackexchange.com/a/12904/117184
list() {
    find "$CKDOTS_CONFIG/dots" -name ".*" -d 1 -exec basename {} \;
}

add_save_dot_file() {
    declare dot="$1"

    mv "$HOME/$dot" "$CKDOTS_CONFIG/dots"
}

add() {
    declare dot="$1"

    dot="$(basename "$dot")"
    if [[ ! -e "$HOME/$dot" ]]; then
        echo "Error: $HOME/$dot is not exist"
        return
    fi

    add_save_dot_file "$dot"
    install_dot_file "$CKDOTS_CONFIG/dots/$dot"
}

status_print_dots() {
    declare dots="$1"

    for dot in $dots; do
        printf "\t%s\n" "$dot"
    done
}

# Find all dotfiles under $1 and sorted lexically
status_find_dots() {
    declare path="$1"

    local dots_found
    local dots

    dots_found="$(find "$path" -name ".*" -maxdepth 1)"
    for dot in $dots_found; do
        if [[ -d "$dot" ]]; then
            dots+=("$(basename "$dot")/")
        else
            dots+=("$(basename "$dot")")
        fi
    done

    echo "${dots[@]}"
}

status() {
    local dots dots_user dots_tracked dots_untracked dots_ignored

    # find -printf "%P" does work on macOS
    dots_user=( "$(status_find_dots "$HOME")" )
    dots_tracked=( "$(status_find_dots "$CKDOTS_CONFIG/dots")" )
    dots_ignored=( "$(printf '%s\n' "${_DOTS_IGNORED[@]}" | sort -f)" )

    # More set operation in shell, see http://www.catonmat.net/blog/set-operations-in-unix-shell/
    dots_untracked=( $(comm -i23 <(printf '%s\n' "${dots_user[@]}") <(printf '%s\n' "${dots_tracked[@]}")) )
    dots_untracked=( $(comm -i23 <(printf '%s\n' "${dots_untracked[@]}") <(printf '%s\n' "${dots_ignored[@]}")) )

    echo 'Tracked dots:'
    for dot in ${dots_tracked[@]}; do
	if [[ "$(readlink "$HOME/$dot")" != "$CKDOTS_CONFIG/dots/$dot" ]]; then
        	printf "\tun-checkout: %s\n" "$dot"
        else
        	printf "\t%s\n" "$dot"
	fi
    done
    echo '
Untracked dots:
  (use "ckdots add <file>..." to include in what will be managed)
'
    status_print_dots "${dots_untracked[*]}"
    echo '
Ignored files:
  (use "ckdots add <file>..." to include in what will be committed)
'
    status_print_dots "${dots_ignored[*]}"
}

backup_dot_file() {
    declare dot_file="$1" backup_dir="$2"
    local dest_file

    # Skiping if file un-exist
    if [[ ! -e "$dot_file" ]]; then
        echo "Skip backing up "$dot_file
        return
    fi

    dest_file="$backup_dir/$(basename "$dot_file").$(date "+%Y%m%d-%H%M%S")"

    mv "$dot_file" "$dest_file"
}

checkout_dot() {
    declare dot="$1"

    backup_dot_file "$HOME/$dot" "$CKDOTS_CONFIG/backup/"
    install_dot_file "$CKDOTS_CONFIG/dots/$dot" "$HOME/"
}

checkout() {
    declare dot="$1"

    dot="$(basename "$dot")"

    if [[ -z "$dot" ]]; then
        local dots_tracked="$(status_find_dots "$CKDOTS_CONFIG/dots")"
    for d in $dots_tracked; do
        checkout_dot "$d"
    done
    else
        checkout_dot "$dot"
    fi
}

main() {

    if [[ -z "$1" ]] || [[ "$1" = help ]] || [[ "$1" = "-h" ]] || [[ "$1" = "--help" ]]; then
        usage
    elif [[ "$1" = install ]]; then
        install
    elif [[ "$1" = ls ]] || [[ "$1" = list ]]; then
        list
    elif [[ "$1" = add ]] && [ $# -gt 1 ]; then
        shift 1
        add "$@"
    elif [[ "$1" = checkout ]]; then
        shift 1
        checkout "$@"
    elif [[ "$1" = status ]]; then
        status
    else
        usage
    fi
}

main "$@"
